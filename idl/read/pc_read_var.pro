; +
; NAME:
;       PC_READ_VAR
;
; PURPOSE:
;       Read var.dat, or other VAR files in any imaginable way!
;
;       Returns one or more fields from a snapshot (var) file generated by a
;       Pencil Code run.  Works for one or all processors. Can select subsets
;       of the data. And pretty much do everything you could dream with a var
;       file.
;
; CATEGORY:
;       Pencil Code, File I/O
;
; CALLING SEQUENCE:
;       pc_read_var, object=object,                               $
;                    varfile=varfile, datadir=datadir, proc=proc, $
;                    /nostats, /quiet, /help
; KEYWORD PARAMETERS:
;    datadir: Specifies the root data directory. Default: './data'.  [string]
;       proc: Specifies processor to get the data from. Default: ALL [integer]
;    varfile: Name of the var file. Default: 'var.dat'.              [string]
;       ivar: Number of the varfile, to be appended optionally.      [integer]
;
;     object: Optional structure in which to return the loaded data. [structure]
;  variables: Array of names of variables to read.                   [string(*)]
;exit_status: Suppress fatal errors in favour of reporting the
;             error through exit_status/=0.
;
;  /allprocs: Load data from the allprocs directory.
;/additional: Load all variables stored in the files, PLUS any additional
;             variables specified with the variables=[] option.
;     /magic: Call pc_magic_var to replace special variable names with their
;             functional equivalents.
;    /global: Add global values to snapshot variables.
;
;   /trimxyz: Remove ghost points from the returned x,y,z arrays.
;   /trimall: Remove ghost points from all returned variables and x,y,z arrays.
;             This is equivalent to wrapping each requested variable with
;             > pc_noghost(..., dim=dim)
;             pc_noghost will skip those variables with an initial size
;             unequal to (dim.mx,dim.my,dim.mz).
;   /unshear: Convert coordinates to unsheared frame (needed for FFT).
;     /ghost: Set ghost zones on derived variables (such as bb).
;
;     /quiet: Suppress any information messages and summary statistics.
;   /nostats: Suppress only summary statistics.
;     /stats: Force printing of summary statistics even if /quiet is set.
;      /help: Display this usage information, and exit.
;
; EXAMPLES:
;       pc_read_var, obj=vars            ;; read all vars into vars struct
;       pc_read_var, obj=vars, proc=5    ;; read only from data/proc5
;       pc_read_var, obj=vars, variables=['ss']
;                                        ;; read entropy into vars.ss
;       pc_read_var, obj=vars, variables=['bb'], /magic
;                                        ;; calculate vars.bb from aa
;       pc_read_var, obj=vars, variables=['bb'], /magic, /additional
;                                        ;; get vars.bb, vars.uu, vars.aa, etc.
;       pc_read_var, obj=vars, /bb       ;; shortcut for the above
;       pc_read_var, obj=vars, variables=['bb'], /magic, /trimall
;                                        ;; vars.bb without ghost points
;
; MODIFICATION HISTORY:
;       $Id$
;       Written by: Antony J Mee (A.J.Mee@ncl.ac.uk), 27th November 2002
;
;-
pro pc_read_var,                                                  $
    object=object, varfile=varfile_, associate=associate,         $
    variables=variables, tags=tags, magic=magic,                  $ 
    bbtoo=bbtoo, ootoo=ootoo,                                     $
    allprocs=allprocs,                                            $
    trimxyz=trimxyz, trimall=trimall, unshear=unshear,            $
    nameobject=nameobject, validate_variables=validate_variables, $
    dim=dim, grid=grid, param=param, par2=par2, ivar=ivar,        $
    datadir=datadir, proc=proc, additional=additional,            $
    nxrange=nxrange, nyrange=nyrange, nzrange=nzrange,            $
    stats=stats, nostats=nostats, quiet=quiet, help=help,         $
    swap_endian=swap_endian, f77=f77, varcontent=varcontent,      $
    global=global, scalar=scalar, run2D=run2D, noaux=noaux,       $
    ghost=ghost, bcx=bcx, bcy=bcy, bcz=bcz,                       $
    exit_status=exit_status

COMPILE_OPT IDL2,HIDDEN
;
; Use common block belonging to derivative routines etc. so we can
; set them up properly.
;
  common cdat,x,y,z,mx,my,mz,nw,ntmax,date0,time0
  common cdat_grid,dx_1,dy_1,dz_1,dx_tilde,dy_tilde,dz_tilde,lequidist,lperi,ldegenerated
  common pc_precision, zero, one
  common cdat_coords,coord_system
;
; Default settings.
;
  default, magic, 0
  default, trimall, 0
  default, unshear, 0
  default, ghost, 0
  default, noaux, 0
  default, bcx, 'none'
  default, bcy, 'none'
  default, bcz, 'none'
  default, validate_variables, 1
  if (arg_present(exit_status)) then exit_status=0
;
; If no meaningful parameters are given show some help!
;
  if (keyword_set(help)) then begin
    doc_library, 'pc_read_var'
    return
  endif
;
; Check if allprocs and/or f77 keyword is set.
;
  if (keyword_set(allprocs)) then begin
    if (n_elements(proc) ne 0) then message, 'pc_read_var: /allproc and proc cannot be both set.'
    if (not keyword_set(f77)) then f77=0
  endif else begin
    allprocs = 0
  endelse
  default, f77, 1
;
; Default data directory.
;
  if (not keyword_set(datadir)) then datadir=pc_get_datadir()
;
; Can only unshear coordinate frame if variables have been trimmed.
;
  if (keyword_set(unshear) and (not keyword_set(trimall))) then begin
    message, 'pc_read_var: /unshear only works with /trimall'
  endif
;
; Name and path of varfile to read.
;
  if (n_elements(ivar) eq 1) then begin
    default, varfile_, 'VAR'
    varfile=varfile_+strcompress(string(ivar),/remove_all)
  endif else begin
    default, varfile_, 'var.dat'
    varfile=varfile_
  endelse
;
; Get necessary dimensions quietly.
;
  if (n_elements(dim) eq 0) then $
      pc_read_dim, object=dim, datadir=datadir, proc=proc, /quiet
  if (n_elements(param) eq 0) then $
      pc_read_param, object=param, dim=dim, datadir=datadir, /quiet
  if (n_elements(par2) eq 0) then begin
    if (file_test(datadir+'/param2.nml')) then begin
      pc_read_param, object=par2, /param2, dim=dim, datadir=datadir, /quiet
    endif else begin
      print, 'Could not find '+datadir+'/param2.nml'
      if (magic) then print, 'This may give problems with magic variables.'
    endelse
  endif
  if (n_elements(grid) eq 0) then $
      pc_read_grid, object=grid, dim=dim, param=param, datadir=datadir, proc=proc, allprocs=allprocs, /quiet
;
; We know from start.in whether we have to read 2-D or 3-D data.
;
  default, run2D, 0
  if (param.lwrite_2d) then run2D=1
;
; Set the coordinate system.
;  
  coord_system=param.coord_system
;
; Read dimensions (global)...
;
  if ((n_elements(proc) eq 1) or (allprocs eq 1)) then begin
    procdim=dim
  endif else begin
    pc_read_dim, object=procdim, datadir=datadir, proc=0, /quiet
  endelse
;
; ... and check pc_precision is set for all Pencil Code tools.
;
  pc_set_precision, dim=dim, quiet=quiet
;
; Should ghost zones be returned?
;
  if (trimall) then trimxyz=1
;
; Local shorthand for some parameters.
;
  nx=dim.nx
  ny=dim.ny
  nz=dim.nz
  nw=dim.nx*dim.ny*dim.nz
  mx=dim.mx
  my=dim.my
  mz=dim.mz
  mvar=dim.mvar
  precision=dim.precision
  mxloc=procdim.mx
  myloc=procdim.my
  mzloc=procdim.mz
;
; Number of processors over which to loop.
;
  if (n_elements(proc) eq 1 or (allprocs eq 1)) then begin
    nprocs=1
  endif else if (allprocs eq 2) then begin
    nprocs=dim.nprocz
    procdim.nx=nx
    procdim.ny=ny
    procdim.mx=mx
    procdim.my=my
    procdim.mw=mx*my*procdim.mz
    procdim.ipx=0
    procdim.ipy=0
    mxloc=mx
    myloc=my
  endif else begin
    nprocs=dim.nprocx*dim.nprocy*dim.nprocz
  endelse
;
; Initialize / set default returns for ALL variables.
;
  t=zero
  x=fltarr(dim.mx)*one
  y=fltarr(dim.my)*one
  z=fltarr(dim.mz)*one
  dx=zero
  dy=zero
  dz=zero
  deltay=zero
;
  if (nprocs gt 1) then begin
    xloc=fltarr(procdim.mx)*one
    yloc=fltarr(procdim.my)*one
    zloc=fltarr(procdim.mz)*one
  endif
;
;  When reading derivative data, do not attempt to read aux variables.
;
  if (varfile eq 'dvar.dat') then noaux=1
;
;  Read meta data and set up variable/tag lists.
;
  default, varcontent, pc_varcontent(datadir=datadir,dim=dim, $
      param=param,quiet=quiet,scalar=scalar,noaux=noaux,run2D=run2D)
  totalvars=(size(varcontent))[1]
;
  if (n_elements(variables) ne 0) then begin
    if (keyword_set(additional)) then begin
      filevars=(varcontent[where((varcontent[*].idlvar ne 'dummy'))].idlvar)
      variables=[filevars,variables]
      if (n_elements(tags) ne 0) then begin
        tags=[filevars,tags]
      endif
    endif
  endif else begin
    default,variables,(varcontent[where((varcontent[*].idlvar ne 'dummy'))].idlvar)
  endelse
;
; Shortcut for getting magnetic field bb.
;
  default, bbtoo, 0
  if (bbtoo) then begin
    variables=[variables,'bb']
    magic=1
  endif
;
; Shortcut for getting vorticity oo.
;
  default, ootoo, 0
  if (ootoo) then begin
    variables=[variables,'oo']
    magic=1
  endif
;
; Default tags are set equal to the variables.
;
  default, tags, variables
;
; Sanity check for variables and tags.
;
  if (n_elements(variables) ne n_elements(tags)) then begin
    message, 'ERROR: variables and tags arrays differ in size'
  endif
;
; Add global parameters (like external magnetic field) to snapshot.
;
  default, global, 0
  if (global) then begin
    pc_read_global, obj=gg, proc=proc, $
        param=param, dim=dim, datadir=datadir, swap_endian=swap_endian, allprocs=allprocs, /quiet
    global_names=tag_names(gg)
  endif
;
; Apply "magic" variable transformations for derived quantities.
;
  if (keyword_set(magic)) then $
      pc_magic_var, variables, tags, $
      param=param, par2=par2, global_names=global_names, $
      datadir=datadir, quiet=quiet
;
; Get a free unit number.
;
  get_lun, file
;
; Prepare for read (build read command).
;
  res=''
  content=''
  for iv=0L,totalvars-1L do begin
    if (nprocs eq 1) then begin
      res=res+','+varcontent[iv].idlvar
    endif else begin
      res=res+','+varcontent[iv].idlvarloc
    endelse
    content=content+', '+varcontent[iv].variable
;
; Initialise read buffers.
;
    if (varcontent[iv].variable eq 'UNKNOWN') then $
        message, 'Unknown variable at position ' + str(iv)  $
        + ' needs declaring in varcontent.pro', /info
    if (execute(varcontent[iv].idlvar+'='+varcontent[iv].idlinit,0) ne 1) then $
        message, 'Error initialising ' + varcontent[iv].variable $
        +' - '+ varcontent[iv].idlvar, /info
    if (nprocs gt 1) then begin
      if (execute(varcontent[iv].idlvarloc+'='+varcontent[iv].idlinitloc,0) ne 1) then $
          message, 'Error initialising ' + varcontent[iv].variable $
          +' - '+ varcontent[iv].idlvarloc, /info
    endif
;
; For vector quantities skip the required number of elements of the f array.
;
    iv=iv+varcontent[iv].skip
  endfor
;
; Display information about the files contents.
;
  content = strmid(content,2)
  if (not keyword_set(quiet)) then begin
    print, ''
    print, 'The file '+varfile+' contains: ', content
    print, ''
    print, 'The grid dimension is ', dim.mx, dim.my, dim.mz
    print, ''
  endif
;
; Loop over processors.
;
  for i=0,nprocs-1 do begin
;
; Build the full path and filename.
;
    if (allprocs eq 2) then begin
      filename=datadir+'/proc'+str(i*dim.nprocx*dim.nprocy)+'/'+varfile
      procdim.ipz=i
    endif else if (allprocs eq 1) then begin
      filename=datadir+'/allprocs/'+varfile
    endif else begin
      if (n_elements(proc) eq 1) then begin
        filename=datadir+'/proc'+str(proc)+'/'+varfile
      endif else begin
        filename=datadir+'/proc'+str(i)+'/'+varfile
        if (not keyword_set(quiet)) then $
            print, 'Loading chunk ', strtrim(str(i+1)), ' of ', $
            strtrim(str(nprocs)), ' (', $
            strtrim(datadir+'/proc'+str(i)+'/'+varfile), ')...'
        pc_read_dim, object=procdim, datadir=datadir, proc=i, /quiet
      endelse
    endelse
;
; Check for existence and read the data.
;
    if (not file_test(filename)) then begin
      if (arg_present(exit_status)) then begin
        exit_status=1
        print, 'ERROR: cannot find file '+ filename
        close, /all
        return
      endif else begin
        message, 'ERROR: cannot find file '+ filename
      endelse
    endif
;
; Setup the coordinates mappings from the processor to the full domain.
;
    if (nprocs gt 1) then begin
;
;  Don't overwrite ghost zones of processor to the left (and
;  accordingly in y and z direction makes a difference on the
;  diagonals).
;
      if (procdim.ipx eq 0L) then begin
        i0x=0L
        i1x=i0x+procdim.mx-1L
        i0xloc=0L
        i1xloc=procdim.mx-1L
      endif else begin
        i0x=procdim.ipx*procdim.nx+procdim.nghostx
        i1x=i0x+procdim.mx-1L-procdim.nghostx
        i0xloc=procdim.nghostx
        i1xloc=procdim.mx-1L
      endelse
;
      if (procdim.ipy eq 0L) then begin
        i0y=0L
        i1y=i0y+procdim.my-1L
        i0yloc=0L
        i1yloc=procdim.my-1L
      endif else begin
        i0y=procdim.ipy*procdim.ny+procdim.nghosty
        i1y=i0y+procdim.my-1L-procdim.nghosty
        i0yloc=procdim.nghosty
        i1yloc=procdim.my-1L
      endelse
;
      if (procdim.ipz eq 0L) then begin
        i0z=0L
        i1z=i0z+procdim.mz-1L
        i0zloc=0L
        i1zloc=procdim.mz-1L
      endif else begin
        i0z=procdim.ipz*procdim.nz+procdim.nghostz
        i1z=i0z+procdim.mz-1L-procdim.nghostz
        i0zloc=procdim.nghostz
        i1zloc=procdim.mz-1L
      endelse
;
; Skip this processor if it makes no contribution to the requested
; subset of the domain.
;
;       if (n_elements(nxrange)==2) then begin
;         if ((i0x gt nxrange[1]+procdim.nghostx) or (i1x lt nxrange[0]+procdim.nghostx)) then continue
;         ix0=max([ix0-(nxrange[0]+procdim.nghostx),0L]
;         ix1=min([ix1-(nxrange[0]+procdim.nghostx),ix0+(nxrange[1]-nxrange[0])]
;       endif
;       if (n_elements(nyrange)==2) then begin
;         if ((i0y gt nyrange[1]+procdim.nghosty) or (i1y lt nyrange[0]+procdim.nghosty)) then continue
;       endif
;       if (n_elements(nzrange)==2) then begin
;         if ((i0z gt nzrange[1]+procdim.nghostz) or (i1z lt nzrange[0]+procdim.nghostz)) then continue
;       endif
    endif
;
; Open a varfile and read some data!
;
    close, file
    openr, file, filename, f77=f77, swap_endian=swap_endian
    if (not keyword_set(associate)) then begin
      if (execute('readu,file'+res) ne 1) then $
          message, 'Error reading: ' + 'readu,' + str(file) + res
    endif else begin
      message, 'Associate behaviour not implemented here yet'
    endelse
;
    if (allprocs eq 1) then begin
      ; collectively written files
      if (f77 eq 0) then begin
        close, file
        openr, file, filename, /f77, swap_endian=swap_endian
        if (precision eq 'D') then bytes=8 else bytes=4
        mvar_io=dim.mvar
        if (param.lwrite_aux) then mvar_io=mvar_io+dim.maux
        point_lun, file, long64(dim.mx*dim.my)*long64(dim.mz*mvar_io*bytes)
      endif
      readu, file, t, x, y, z, dx, dy, dz
    endif else if (nprocs eq 1) then begin
      ; single processor distributed file
      if (param.lshear) then begin
        readu, file, t, x, y, z, dx, dy, dz, deltay
      endif else begin
        readu, file, t, x, y, z, dx, dy, dz
      endelse
    endif else begin
      if (allprocs eq 2) then begin
        ; xy-collectively written files for each ipz-layer
        if (f77 eq 0) then begin
          close, file
          openr, file, filename, /f77, swap_endian=swap_endian
          if (precision eq 'D') then bytes=8 else bytes=4
          point_lun, file, long64(dim.mx*dim.my)*long64(procdim.mz*dim.mvar*bytes)
        endif
        if (i eq 0) then begin
          readu, file, t
          readu, file, x, y, z, dx, dy, dz
        endif else begin
          t_test = zero
          readu, file, t_test
          if (t ne t_test) then begin
            print, "ERROR: TIMESTAMP IS INCONSISTENT: ", filename
            print, "t /= t_test: ", t, t_test
            print, "Type '.c' to continue..."
            stop
          endif
        endelse
      endif else begin
        ; multiple processor distributed files
        if (param.lshear) then begin
           readu, file, t, xloc, yloc, zloc, dx, dy, dz, deltay
        endif else begin
          readu, file, t, xloc, yloc, zloc, dx, dy, dz
        endelse
        if (i eq 0) then begin
          t_test = t
        endif else begin
          if (t ne t_test) then begin
            print, "ERROR: TIMESTAMP IS INCONSISTENT: ", filename
            print, "t /= t_test: ", t, t_test
            print, "Type '.c' to continue..."
            stop
            t = t_test
          endif
        endelse
;
        x[i0x:i1x] = xloc[i0xloc:i1xloc]
        y[i0y:i1y] = yloc[i0yloc:i1yloc]
        z[i0z:i1z] = zloc[i0zloc:i1zloc]
      endelse
;
; Loop over variables.
;
      for iv=0L,totalvars-1L do begin
        if (varcontent[iv].variable eq 'UNKNOWN') then continue
;
; For 2-D run with lwrite_2d=T we only need to read 2-D data.
;
        if (keyword_set(run2D)) then begin
          if (nx eq 1) then begin
; 2-D run in (y,z) plane.
            cmd =   varcontent[iv].idlvar $
                + "[dim.l1,i0y:i1y,i0z:i1z,*,*]=" $
                + varcontent[iv].idlvarloc $
                +"[i0yloc:i1yloc,i0zloc:i1zloc,*,*]"
          endif else if (ny eq 1) then begin
; 2-D run in (x,z) plane.
            cmd =   varcontent[iv].idlvar $
                + "[i0x:i1x,dim.m1,i0z:i1z,*,*]=" $
                + varcontent[iv].idlvarloc $
                +"[i0xloc:i1xloc,i0zloc:i1zloc,*,*]"
          endif else begin
; 2-D run in (x,y) plane.
            cmd =   varcontent[iv].idlvar $
                + "[i0x:i1x,i0y:i1y,dim.n1,*,*]=" $
                + varcontent[iv].idlvarloc $
                +"[i0xloc:i1xloc,i0yloc:i1yloc,*,*]"
          endelse 
        endif else begin
;
; Regular 3-D run.
;        
          cmd =   varcontent[iv].idlvar $
              + "[i0x:i1x,i0y:i1y,i0z:i1z,*,*]=" $
              + varcontent[iv].idlvarloc $
              +"[i0xloc:i1xloc,i0yloc:i1yloc,i0zloc:i1zloc,*,*]"
        endelse
        if (execute(cmd) ne 1) then $
            message, 'Error combining data for ' + varcontent[iv].variable
;
; For vector quantities skip the required number of elements.
;
        iv=iv+varcontent[iv].skip
      endfor
;
    endelse
;
    if (not keyword_set(associate)) then begin
      close,file
      free_lun,file
    endif
  endfor
;
; Tidy memory a little.
;
  if (nprocs gt 1) then begin
    undefine,xloc
    undefine,yloc
    undefine,zloc
    for iv=0L,totalvars-1L do begin
      undefine, varcontent[iv].idlvarloc
    endfor
  endif
;
; Set ghost zones on derived variables (not default).
;
  if (keyword_set(ghost)) then begin
    for iv=0,n_elements(variables)-1 do begin
; Check that only derived variables get their ghost zones set.
      if (total(variables[iv] eq varcontent.idlvar) eq 0) then begin
        variables[iv] = 'pc_setghost('+variables[iv]+',bcx='''+bcx+''',bcy='''+bcy+''',bcz='''+bcz+''',param=param,t=t)'
      endif
    endfor
  endif
;
; Check variables one at a time and skip the ones that give errors.
; This way the program can still return the other variables, instead
; of dying with an error. One can turn off this option off to decrease
; execution time.
;
  if (validate_variables) then begin
    skipvariable=make_array(n_elements(variables),/INT,value=0)
    for iv=0,n_elements(variables)-1 do begin
      if (tags[iv] eq variables[iv]) then continue
      res=execute(tags[iv]+'='+variables[iv])
      if (not res) then begin
        if (not keyword_set(quiet)) then $
            print,"% Skipping: "+tags[iv]+" -> "+variables[iv]
        skipvariable[iv]=1
      endif
    endfor
    if (min(skipvariable) ne 0) then return
    if (max(skipvariable) eq 1) then begin
      variables=variables[where(skipvariable eq 0)]
      tags=tags[where(skipvariable eq 0)]
    endif
  endif
;
; Save changs to the variables array (but don't include the effect of /TRIMALL).
;
  variables_in=variables
;
; Trim x, y and z if requested.
;
  if (keyword_set(trimxyz)) then begin
    xyzstring="x[dim.l1:dim.l2],y[dim.m1:dim.m2],z[dim.n1:dim.n2]"
  endif else begin
    xyzstring="x,y,z"
  endelse
;
; Remove ghost zones if requested.
;
  if (keyword_set(trimall)) then variables = 'pc_noghost('+variables+',dim=dim)'
;
; Transform to unsheared frame if requested.
;
  if (keyword_set(unshear)) then variables = 'pc_unshear('+variables+',param=param,xax=x[dim.l1:dim.l2],t=t)'
;
; Make structure out of the variables.
;
  if (param.lshear) then begin
    makeobject = "object = "+ $
        "CREATE_STRUCT(name=objectname,['t','x','y','z','dx','dy','dz','deltay'" + $
        arraytostring(tags,QUOTE="'") + "],t,"+xyzstring+",dx,dy,dz,deltay" + $
        arraytostring(variables) + ")"
  endif else begin
    makeobject = "object = "+ $
        "CREATE_STRUCT(name=objectname,['t','x','y','z','dx','dy','dz'" + $
        arraytostring(tags,QUOTE="'") + "],t,"+xyzstring+",dx,dy,dz" + $
        arraytostring(variables) + ")"
  endelse
;
; Execute command to make the structure.
;
  if (execute(makeobject) ne 1) then begin
    message, 'ERROR evaluating variables: '+makeobject
    undefine, object
  endif
;
; If requested print a summary (actually the default - unless being quiet).
;
  if (keyword_set(stats) or $
     (not (keyword_set(nostats) or keyword_set(quiet)))) then begin
    if (not keyword_set(quiet)) then begin
      print, ''
      print, '                             Variable summary:'
      print, ''
    endif
    pc_object_stats, object, dim=dim, trim=trimall, quiet=quiet
    print, ' t = ', t
    print, ''
  endif
;
end
