; +
; NAME:
;       PC_READ_SLICE_RAW
;
; PURPOSE:
;       Read slices from var.dat, or other VAR files in an efficient way!
;
;       Returns one array from a snapshot (var) file generated by a
;       Pencil Code run, and another array with the variable labels.
;       Works only for collectively written (io_collect module)
;       or for collected (using pc_collect.x) snapshot files.
;
; CATEGORY:
;       Pencil Code, File I/O
;
; CALLING SEQUENCE:
;       pc_read_slice_raw, object=object, varfile=varfile, tags=tags, $
;                    datadir=datadir, trimall=trimall, /quiet,        $
;                    swap_endian=swap_endian, time=time, grid=grid,   $
;                    cut_x=cut_x, cut_y=cut_y, cut_z=cut_z
; KEYWORD PARAMETERS:
;    datadir: Specifies the root data directory. Default: './data'.  [string]
;    varfile: Name of the collective snapshot. Default: 'var.dat'.   [string]
;
;      cut_x: x-coordinate of the yz-plane cut.                      [integer]
;      cut_y: y-coordinate of the xz-plane cut.                      [integer]
;      cut_z: z-coordinate of the xy-plane cut.                      [integer]
;             Exactly one of them must be set in the interval (0,ngrid-1).
;
;     object: Optional structure in which to return the loaded data. [4D-array]
;       tags: Array of tag names inside the object array.            [string(*)]
;
;   /trimall: Remove ghost points from the returned data.
;     /quiet: Suppress any information messages and summary statistics.
;
; EXAMPLES:
;       pc_read_slice_raw, obj=vars, tags=tags
;
;       cslice, vars
; or:
;       cmp_cslice, { uz:vars[*,*,*,tags.uz], lnrho:vars[*,*,*,tags.lnrho] }
;
; MODIFICATION HISTORY:
;       $Id$
;       Adapted from: pc_read_var_raw.pro, 4th May 2012
;
;-
pro pc_read_slice_raw,                                                $
    object=object, varfile=varfile, datadir=datadir, tags=tags,       $
    dim=dim, param=param, par2=par2, varcontent=varcontent,           $
    trimall=trimall, quiet=quiet, swap_endian=swap_endian, time=time, $
    grid=grid, cut_x=cut_x, cut_y=cut_y, cut_z=cut_z

COMPILE_OPT IDL2,HIDDEN
;
; Use common block belonging to derivative routines etc. so we can
; set them up properly.
;
  common cdat,x,y,z,mx,my,mz,nw,ntmax,date0,time0
  common cdat_grid,dx_1,dy_1,dz_1,dx_tilde,dy_tilde,dz_tilde,lequidist,lperi,ldegenerated
  common pc_precision, zero, one
  common cdat_coords,coord_system
;
; Default settings.
;
  default, swap_endian, 0
  default, cut_x, -1
  default, cut_y, -1
  default, cut_z, -1
  addname = ""
;
  if (total([cut_x, cut_y, cut_z] < 0) ne -2) then $
      message, 'pc_read_slice_raw: Please set exactly one cut index.'
;
; Default data directory.
;
  if (not keyword_set(datadir)) then datadir=pc_get_datadir()
;
; Name and path of varfile to read.
;
  if (not keyword_set(varfile)) then varfile = 'var.dat'
;
; Get necessary dimensions quietly.
;
  if (n_elements(dim) eq 0) then $
      pc_read_dim, object=dim, datadir=datadir, /quiet
  if (n_elements(param) eq 0) then $
      pc_read_param, object=param, dim=dim, datadir=datadir, /quiet
  if (n_elements(par2) eq 0) then begin
    if (file_test(datadir+'/param2.nml')) then begin
      pc_read_param, object=par2, /param2, dim=dim, datadir=datadir, /quiet
    endif else begin
      print, 'Could not find '+datadir+'/param2.nml'
    endelse
  endif
  if (n_elements(grid) eq 0) then $
      pc_read_grid, object=grid, dim=dim, param=param, datadir=datadir, /allprocs, /quiet
;
; Set the coordinate system.
;  
  coord_system=param.coord_system
;
; Read dimensions (global)...
;
  procdim=dim
;
; ... and check pc_precision is set for all Pencil Code tools.
;
  pc_set_precision, dim=dim, quiet=quiet
;
; Local shorthand for some parameters.
;
  nx=dim.nx
  ny=dim.ny
  nz=dim.nz
  nw=dim.nx*dim.ny*dim.nz
  mx=dim.mx
  my=dim.my
  mz=dim.mz
  mvar=dim.mvar
  precision=dim.precision
;
; Set cut parameters.
;
  if (cut_x eq -1) then begin
    cut_nx = dim.mx
    px_start = 0
  endif else begin
    if ((cut_x lt 0) or (cut_x ge dim.nx)) then $
        message, 'pc_read_slice_raw: cut_x is invalid, min/max: 0-'+strtrim(dim.nx-1, 2)
    cut_nx = 1 + 2*dim.nghostx
    px_start = cut_x
  endelse
  px_end = px_start + cut_nx - 1
;
  if (cut_y eq -1) then begin
    cut_ny = dim.my
    py_start = 0
  endif else begin
    if ((cut_y lt 0) or (cut_y ge dim.ny)) then $
        message, 'pc_read_slice_raw: cut_y is invalid, min/max: 0-'+strtrim(dim.ny-1, 2)
    cut_ny = 1 + 2*dim.nghosty
    py_start = cut_y
  endelse
  py_end = py_start + cut_ny - 1
;
  if (cut_z eq -1) then begin
    cut_nz = dim.mz
    pz_start = 0
  endif else begin
    if ((cut_z lt 0) or (cut_z ge dim.nz)) then $
        message, 'pc_read_slice_raw: cut_z is invalid, min/max: 0-'+strtrim(dim.nz-1, 2)
    cut_nz = 1 + 2*dim.nghostz
    pz_start = cut_z
  endelse
  pz_end = pz_start + cut_nz - 1
;
; Initialize / set default returns for ALL variables.
;
  t=zero
  x=fltarr(dim.mx)*one
  y=fltarr(dim.my)*one
  z=fltarr(dim.mz)*one
  dx=zero
  dy=zero
  dz=zero
  deltay=zero
;
;  Read meta data and set up variable/tag lists.
;
  if (n_elements(varcontent) eq 0) then $
      varcontent=pc_varcontent(datadir=datadir,dim=dim,param=param,quiet=quiet)
  totalvars=(size(varcontent))[1]
;
; Initialise read buffers.
;
  if (precision eq 'D') then begin
    bytes = 8
    object = dblarr (cut_nx, cut_ny, cut_nz, totalvars)
    buffer = dblarr (cut_nx)
  endif else begin
    bytes = 4
    object = fltarr (cut_nx, cut_ny, cut_nz, totalvars)
    buffer = fltarr (cut_nx)
  endelse
;
; Display information about the files contents.
;
  tag_str = ''
  content = ''
  for iv=0L, totalvars-1L do begin
    if (varcontent[iv].idlvar eq "uu") then begin
      tag_str += ', ux:' + strtrim (iv, 2) + ', uy:' + strtrim (iv+1, 2) + ', uz:' + strtrim (iv+2, 2)
    endif else if (varcontent[iv].idlvar eq "aa") then begin
      tag_str += ', ax:' + strtrim (iv, 2) + ', ay:' + strtrim (iv+1, 2) + ', az:' + strtrim (iv+2, 2)
    endif else begin
      tag_str += ', ' + varcontent[iv].idlvar + ':' + strtrim (iv, 2)
    endelse
    content += ', '+varcontent[iv].variable
    ; For vector quantities skip the required number of elements of the f array.
    iv += varcontent[iv].skip
  endfor
  tag_str = 'tags = { ' + strmid (tag_str, 2) + ' }'
  content = strmid (content, 2)
  if (not keyword_set(quiet)) then begin
    print, ''
    print, 'The file '+varfile+' contains: ', content
    print, ''
    print, 'The grid dimension is ', dim.mx, dim.my, dim.mz
    print, ''
  endif
  if (execute (tag_str) ne 1) then message, 'Error executing: ' + tag_str
;
; Build the full path and filename.
;
  filename = datadir+'/allprocs/'+varfile
;
; Check for existence and read the data.
;
  if (not file_test(filename)) then $
      message, 'ERROR: File not found "'+filename+'"'
;
; Open a varfile and read some data!
;
  openr, lun, filename, swap_endian=swap_endian, /get_lun
  mx = long64(dim.mx)
  mxy = mx * dim.my
  mxyz = mxy * dim.mz
  for pa = 0, totalvars-1 do begin
    for pz = pz_start, pz_end do begin
      for py = py_start, py_end do begin
        point_lun, lun, bytes * (px_start + py*mx + pz*mxy + pa*mxyz)
        readu, lun, buffer
        object[0:px_end-px_start,py-py_start,pz-pz_start,pa] = buffer
      endfor
    endfor
  endfor
  close, lun
;
  openr, lun, filename, /f77, swap_endian=swap_endian
  point_lun, lun, long64(dim.mx*dim.my)*long64(dim.mz*dim.mvar*bytes)
  readu, lun, t, x, y, z, dx, dy, dz
  close, lun
  free_lun, lun
;
; Tidy memory a little.
;
  undefine, buffer
;
; Crop grid.
;
  x = x[px_start:px_end]
  y = y[py_start:py_end]
  z = z[pz_start:pz_end]
  dim.mx = cut_nx
  dim.my = cut_ny
  dim.mz = cut_nz
  dim.nx = cut_nx - 2*dim.nghostx
  dim.ny = cut_ny - 2*dim.nghosty
  dim.nz = cut_nz - 2*dim.nghostz
  dim.mxgrid = dim.mx
  dim.mygrid = dim.my
  dim.mzgrid = dim.mz
  dim.nxgrid = dim.nx
  dim.nygrid = dim.ny
  dim.nzgrid = dim.nz
  dim.mw = dim.mx * dim.my * dim.mz
  if (cut_x ne -1) then dim.l2 = dim.mx - dim.nghostx - 1
  if (cut_y ne -1) then dim.m2 = dim.my - dim.nghosty - 1
  if (cut_z ne -1) then dim.n2 = dim.mz - dim.nghostz - 1
;
; Prepare for derivatives.
;
  dx_1 = grid.dx_1[px_start:px_end]
  dy_1 = grid.dy_1[py_start:py_end]
  dz_1 = grid.dz_1[pz_start:pz_end]
  dx_tilde = grid.dx_tilde[px_start:px_end]
  dy_tilde = grid.dy_tilde[py_start:py_end]
  dz_tilde = grid.dz_tilde[pz_start:pz_end]
  if (cut_x ne -1) then Lx = 1.0/dx_1[dim.nghostx] else Lx = grid.Lx
  if (cut_y ne -1) then Ly = 1.0/dy_1[dim.nghosty] else Ly = grid.Ly
  if (cut_z ne -1) then Lz = 1.0/dz_1[dim.nghostz] else Lz = grid.Lz
;
; Remove ghost zones if requested.
;
  if (keyword_set(trimall)) then begin
    object = reform (object[dim.l1:dim.l2,dim.m1:dim.m2,dim.n1:dim.n2,*])
    x = x[dim.l1:dim.l2]
    y = y[dim.m1:dim.m2]
    z = z[dim.n1:dim.n2]
    dx_1 = dx_1[dim.l1:dim.l2]
    dy_1 = dy_1[dim.m1:dim.m2]
    dz_1 = dz_1[dim.n1:dim.n2]
    dx_tilde = dx_tilde[dim.l1:dim.l2]
    dy_tilde = dy_tilde[dim.m1:dim.m2]
    dz_tilde = dz_tilde[dim.n1:dim.n2]
    addname += "trimmed_"
  endif
;
  if (not keyword_set(quiet)) then begin
    print, ' t = ', t
    print, ''
  endif
;
  time = t
  name = "pc_read_slice_raw_"+addname+strtrim (cut_nx, 2)+"_"+strtrim (cut_ny, 2)+"_"+strtrim (cut_nz, 2)
  grid = create_struct (name=name, $
      ['t', 'x', 'y', 'z', 'dx', 'dy', 'dz', 'Lx', 'Ly', 'Lz', 'dx_1', 'dy_1', 'dz_1', 'dx_tilde', 'dy_tilde', 'dz_tilde'], $
      t, x, y, z, dx, dy, dz, Lx, Ly, Lz, dx_1, dy_1, dz_1, dx_tilde, dy_tilde, dz_tilde)
;
end
